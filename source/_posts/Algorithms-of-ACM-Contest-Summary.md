title: Algorithms of ACM Contest Summary
tags:
  - Algorithm
  - Summary
date: 2015-03-22 20:55:37
catagories:
---
*(2015/07/19 更新BST)*

四五年没有再去好好温习ACM方面的东西了，不过这一块其实时不时还是会提到，姑且做个简陋的算法方面的总结吧~时间精力有限，能总结多少是多少了。
这里写法同样是"复习用"。[NOCOW](http://www.nocow.cn/index.php/%E9%A6%96%E9%A1%B5)会比我说得更加详细清楚:P

##动态规划(背包/博弈/树状/字符串/状态压缩等)
动态规划，核心在于定义"状态"及"状态转移方程"。
<!--more-->

**背包**
有限空间内放置各种价值不同资源(物品)的最优值问题。这个问题[崔添翼大牛](https://github.com/tianyicui/)在《背包九讲》里面讲得超清楚，简单概括一下好了。

1.  01背包：各种物品只有一件。$F[i,v]=max\\{F[i-1,v],F[i-1,v-C\_i]+W\_i\\}$，即选择取或不取。循环每件物品时，如倒序扫描DP数组，可以降低一维空间复杂度。
2.  完全背包：各种物品无限件。$F[i,v]=max\\{F[i-1,v],F[i,v-C\_i]+W\_i\\}$。01背包改成顺序扫描DP数组就可以了。预处理去掉明显性价比低的物品，能进一步优化。
3.  多重背包：各种物品$M\_i$件。$F[i,v]=max\\{F[i-1,v-kC\_i]+kW\_i\\},0\le k\le M\_i$。可以将$M\_i$拆分成二进制表示的多件物品，进行01背包，优化复杂度。*单调队列优化容后补充*
4.  多维背包：以上问题扩展到多维有限空间。二维为例，$F[i,v,u]=max\\{F[i-1,v,u],F[i-1,v-C\_i,u-D\_i]+W\_i\\}$，多一重循环就好了，比如二维01背包就两重倒序扫描。
5.  分组背包：以上问题的物品分组，每组最多取一件。$F[k,v]=max\\{F[k-1,v],F[k-1,v-C\_i]+W\_i\\},i\in 组k$。先循环组，再倒序扫描DP数组每次取组内一件。
6.  有依赖的背包：以上问题选用物品要满足依赖关系，依赖关系是一个森林。由于每一个节点及其儿子都有$2^k$种选择，这相当于多次背包的结果再合并的问题。就用树状DP的方法，从叶子开始，每一个节点都进行一次01背包减少选择。

其他技巧：

*   定义状态，可以定义"花费刚好为v时的最优值"和"花费至多为v时的最优值"两种；
*   记录最优方案，则开多一个数组记录来源状态，及状态转移选择(如果来源状态不暗含的话)；
*   求方案总数，最小值等，则将max改成sum、min；
*   求第K优解，则在状态数组中多开一维(就是每个状态变一个队列)，记录前K优解。

**博弈**
博弈论的状态一般是很明显的，关键是要从胜负状态反推状态转移方程。

*   SG博弈：最经典的是NIM游戏。【待补充】。参见[这里](http://blog.csdn.net/logic_nut/article/details/4711489)

**树状**
一般从子节点开始归纳状态转移。这方面的总结太杂乱，【待补充】。

**序列/字符串**

*   最大子矩阵 悬线法

**插头**
二维平面，对连通性有要求，逐格进行状态转移的DP，并且每个格子的状态需要进行压缩。
压缩方法包括：
1. 连通的格子用同一标号表示。
2. 路线不能交叉，标号只用两个就够。
3. 扩大成使用$2^k$进制，位运算来转移
更多介绍见[论文PPT](http://wenku.baidu.com/view/4fe4ac659b6648d7c1c74633.html)

**相关优化**

*   滚动数组：因为动态规划方程中，最外层循环每次往往只需要用到上一次循环的数据，所以只开能够存下两次大循环的空间就好，而不是全部循环的空间。
*   状态压缩：
*   单调队列：一般应用于状态转移中，要求旧状态带有"最大/最小"条件的问题。关键是发现可以抛弃掉的、更老的状态，作为单调队列可抛弃的状态。对于有区间限制的题目，可以将{状态值，状态位置}对建成单调双端队列，左限制右求最值。每次状态转移时就可以从单调队列中提取，而不必往前扫描。没有区间限制求第k大/k小的题目，若发现了可抛弃的状态，亦可构建一个单调序列，用二分查找提取(最长不下降子序列)。[见此总结](http://www.cnblogs.com/neverforget/archive/2011/10/13/ll.html)
*   优先队列/堆优化：

##树与图论(最短路/生成树等)

**Adjacency List**
![](http://i57.tinypic.com/2czavls.jpg)

**Topological Sort**
【待补充】

**Huffman Coding**
【待补充】

**Dijkstra**
正权图单源最短路，以贪心为基础。维护一个数组，记录源点到每个点当前已知最短路边权和，初始除了源点全为无穷大。循环V次，每次取数组中的最小值，即为到该对应点的最短路。$O(V^2)$

*   也可以用邻接表保存边，维护一个二叉堆而不是数组。$O((E+V)logV)$

**Bellman-ford**
任意图单源最短路。遍历V-1次边集进行松弛。如果遍历后还有边可以松弛，则存在负权环。$O(VE)$

**SPFA**
用队列优化Bellman-ford算法。一开始只有源点在队列中。每次循环遍历队头的点的邻边，所有被松弛的点加入队列。如果某个点的入队次数超过V，则存在负权环。

设最短路边权和为dist[i]   

*   SLL优化：对于要入队的元素i，队首j，若$dist[i] < dist[j]$，i插入队首； 
*   LLL优化：队首j，若$dist[j] < average(dist[])$，j延至队尾处理； 

核心思路是提前可能更优的松弛。加上两个优化平均可提速50%。

**Floyd-warshall**
任意图多源最短路，动态规划为基础。维护一个邻接矩阵，三重循环，每次以对角线的点为中心作十字用v[i,k]+v[k,j]更新v[i,j]。$O(V^3)$

**Prim**
任意图的最小生成树算法。维护一个数组，记录每个"已到点"连接某个"未到点"的最小边权。循环V次，每次取数组中的最小值，对应边即为最小生成树树枝，对应点加入"已到点"。$O(V^2)$

*   也可以用邻接表保存边，维护一个二叉堆而不是数组，但写这个不如写Kruskal。$O((E+V)logV)$

**Kruskal**
任意图的最小生成树算法。边集按权值从小到大排序逐条尝试加入解，并维护一个并查集以保证不形成环路，直到成功加入V-1条边。$O(VlogV+ElogE)$

**Kosaraju**
有向图求强连通分支(任意点相互可达)的算法。先DFS一次记录访问顺序，然后所有边取反，逆访问顺序多次DFS，每次DFS到的点即为一个强连通分支。

*   类似的算法还有Tarjan和Gabow，不过时间复杂度的优化并不算太大，暂时不写啦

##网络流(二分图匹配等)
重要定理：最大流=最小割。
**Ford-Fulkerson**
网络流算法的基础思想。不断简单地DFS寻找一条增广路。
**Edmonds-Karp**
每次BFS出一条长度最短的增广路。BFS时使用临时数组推演可能作出的流量变化。
**Dinic** 
优化后的求最大流算法。每次先BFS建立层次图(离源点距离i的点在第i层)，然后DFS逐层递归找一条增广路(能增加流量的路径，流量为路径中权值最小的边)，然后增广值加入总流量，并把整条增广路反向。循环至汇点不能到达。动画及代码见[这里](http://comzyh.com/blog/archives/568/)。
**SAP**
相比Dinic，常数上更快但是代码行数和细节更多的算法。初始化时先BFS建立层次图（SAP是里汇点的距离）。然后循环进行原点出发的回溯(DFS写成while)来寻找增广路。每条可行弧必须刚好降一层。如果某个点没有可行弧，就更新它的层次值为min{它可以去的相邻点的层次值}，再继续回溯。直到没有属于某个中间层次的点出现断层，或者源点层次值大于等于点数n了。评价见[这里](http://fanhq666.blog.163.com/blog/static/81943426201072554322479/)。
**Hungarian**
求最大二分图匹配的算法。左半部每个点依次贪心，每次出发递归寻找右边一个可增广的未连接点后即可。

##数据结构(包括线段树等)

**Monotonic Queue**
一个双端队列，左边抛掉不符合新条件的旧元素，右边新元素入队时抛掉不能保持单调性的。
能够求最大最小/k大k小问题。经常被用于优化动态规划算法。
**Segmentation tree**
一个节点记录一条线段的值，子节点将父节点代表线段对半分。由于对半分的特性，线段树是完全二叉树，每个节点表示的线段可以推导出(作为递归参数)而不必记录。更新/询问时要么递归下去直到叶节点。要么lazy优化，节点线段被包含在要求线段之内就好。如果有必要就记录这个节点这次更新的值。下次需要更加细化地更新/询问时，再将这个值往下推。反正因为包含关系，叶节点更新的量是一样的。
二维问题也可能用到线段树(扫描线法)，如求矩形面积叠合后和，x轴作为离散化的线段建立线段树，然后按y轴顺序往树上添加矩形的上底和下底，并记录每条线段目前是被上底覆盖还是下底覆盖，这样添加的时候就可以算面积。参考[这里](http://notonlysuccess.me/?p=978)。
**Disjoint Set**
数组记录的树，记录父节点及子树元素个数。
1. 查找：递归查找出树根a，然后沿路将父节点全部置为a
2. 合并：要合并的两个节点分别查找出树根a,b，然后元素少的树根a父节点置为b
**BST**
搜索树是一系列方便快速查找的数据结构。最简单的BST，左儿子小右儿子大，建树、插入、查找都是从树根开始的递归。删除则是该结点与左子树的最大结点互换后删除（因为这个结点不可能有两棵子树。如果换右子树最小也可以）
**AVL**
左右子树深度差最多是1。在BST的操作以外，插入完后往上一层算平衡度(左树高减右树高)，如果要进行平衡，看被插入的子子树相对该结点位置。如果路径是LL或RR就单旋，如果是RL或LR就双旋(比如先在儿子左旋，再在该结点右旋)。删除也一样。
每次插入至多只需要做一次单旋或双旋。删除删成链状的话可能要两次。不过不想写那么细节的话还是都检查并更新了吧。
所有操作平均及最坏情况都是O(logN)。旋转平均只需O(1)。
**Splay**
思路是将要访问的结点比较平衡地旋转(Splay)到树根，这样访问比较频繁的结点都在树根附近。和AVL一样是看结点、父结点和祖父结点的走向关系，LL/RR就单旋/连续单旋(Zig/Zig-Zig)，LR/RL就双旋(Zig-Zag)。插入/查找都是旋转该点到根节点。删除则是把替换前的父节点旋转到根节点(有其他算法变种)。分裂是把作为分裂界的结点旋转到树根后切掉左子树或右子树变成一大一小两棵树。合并的话两棵树必须一大一小，把小树的最大元素旋转到根然后合并。
虽然单次最坏情况可能有O(n)，均摊复杂度也是O(logN)。长远来看比AVL平均更快，实现逻辑比AVL简单，还支持合并和拆分，不过不能用于并行环境中。
**Red-Black**
和AVL树类似。【待补充】
平衡度要求没有AVL严格。所以插入和删除相比更快，而查找更慢。
**Treap**
**SBT**
**Binary Heap**
**Skew Heap**
**Leftist Heap**
**Fibonacci Heap**
**Binomial Heap**
**Trie**
**B & B-**
**Hash Table**

##数学&几何(凸包等)

##思路/基本功(二分答案/贪心/搜索/排序等)

**排序算法**

ACM非常少用到，姑且就当算法课基础复习了

*   Bubble：每次第i个元素网上冒泡。稳定。
*   Insertion：每次第i个元素在已排序元素中找到应插入位置，后面的已排序元素逐个后移。稳定。
*   Selection：每次选未排序元素中的最大的，与数组最前面元素交换。不稳定。
*   Shell：设一个增量，相隔是增量的倍数的为同一组，分组插入排序；增量不断折半。不稳定。复杂度略大于O(NlogN)。
*   Quick：每次选一个Key，左右两端各自扫描，小于Key的放一边，大于Key的放另一边，扫描index仍未交错则交换元素，递进index继续扫描，递归分治此过程。Key的选择可以是固定，或优化为随机 / 前中后三元素比较选中值        。不稳定。
*   Heap：建堆(从倒数第二层开始倒着逐个下滤)，逐个删掉根节点(下滤)，删完的数组就是了。
*   Merge：分治到底回溯归并，每层用临时数组归并两端，再把归并好的值放回去。不稳定。
*   Radix：顺序循环每一个十进制位，每次根据该位数字放入桶中再连起来。稳定。复杂度O(dN)，近似O(NlogN)。
*   Bin：将数据根据关键字分发到多个有序桶中，桶内有多个元素再进行上述的比较排序。稳定。
*   Intro：开始采用快速排序算法进行排序,当递归达到一定深度时就改为堆排序来处理。

**字符串匹配算法**

*   KMP
*   Sunday(http://blog.csdn.net/WINCOL/article/details/4795369)

**搜索算法及技巧**

* 深度限制DFS
* A*

**C++ STL**
虽然STL和算法无关，但是由于STL的存在，很多数据结构不用自己写，是ACM比赛中必备外挂……

容器：操作包括begin, end, rbegin, rend, erase(,), clear
**1. 标准序列容器**：
`list<>` `vector<>` `deque<>`，内存分配分别是连续，小片连续，不连续。
常用操作（各类略有出入请自行琢磨，下同）: empty, front, back, push\_front(), push\_back(), pop\_front, pop\_back, max\_size, reverse, insert(,,), remove(), remove\_if(), assign(,), swap(), at(), unique, sort

**2. 标准关联容器**：
`set<>` `multiset<>` `map<,>` `multimap<,>`，对应集合，可重复集合，一对一映射，一对多映射。红黑树实现。


**3. 容器适配器**：
标准序列容器变种，提供受限的底层容器接口，没有迭代器
`queue<int>` `queue<int,list<int>>`，默认deque作为底层容器，包括操作push,pop,front,back,empty,size
`priority_queue<int>` `priority_queue<int, vector<int>, greater<int>>`，默认使用vector作为底层容器，包括操作top,push,pop,empty,size
`stack<>`
**4. 似容器**：
`string<>` `valarray<>` `bitset<>`
**5. 容器迭代器**：
`vector<int>::iterator` `vector<int>::const_iterator`

算法：
1. 以下内容需要`#include <algorithm>`
sort(begin,end,cmp), 相比c的qsort，用的是intro_sort，不会退化
2. 以下内容需要`#include <functional>`
greater<> 【待补充】[见这里](http://www.baidu.com/s?ie=utf8&oe=utf8&wd=C%2B%2B%20greater&tn=90128732_hao_pg&ch=2&lans=132),[以及这里](http://wenku.baidu.com/link?url=FQ_M_OG2UgNqJLngZgSQlAeek-0B21j9QoMkvUgrmdq9W1TWoqotNGEvVUuqDn1NdqsBMmntGyyPcsDMj3gVJsLhCRolj2OZxBTnkc0-2Ii)
less<>


算法可视化参考：
https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

